const express = require('express');
const http = require('http');
const socketIo = require('socket.io');
const path = require('path');

const app = express();
const server = http.createServer(app);
const io = socketIo(server);

// Serve static files
app.use(express.static(path.join(__dirname, 'public')));

// Game state
let players = {};
let food = [];
const GRID_SIZE = 20;
const CANVAS_SIZE = 20; // 20x20 grid

// Generate initial food
function generateFood() {
    food = [];
    for (let i = 0; i < 5; i++) {
        food.push({
            x: Math.floor(Math.random() * GRID_SIZE),
            y: Math.floor(Math.random() * GRID_SIZE)
        });
    }
}

generateFood();

// Player colors
const COLORS = ['#4CAF50', '#2196F3', '#9C27B0', '#FF9800', '#F44336', '#00BCD4'];

io.on('connection', (socket) => {
    console.log('New player connected:', socket.id);
    
    // Send player their ID
    socket.emit('player-id', socket.id);
    
    // Send current game state
    socket.emit('game-state', { players, food });
    
    // Update online count
    updateOnlineCount();
    
    // Handle login
    socket.on('login', (playerName) => {
        players[socket.id] = {
            id: socket.id,
            name: playerName,
            color: COLORS[Object.keys(players).length % COLORS.length],
            body: [{x: 10, y: 10}],
            direction: {x: 0, y: 0},
            score: 0
        };
        
        // Notify all players
        io.emit('player-joined', players[socket.id]);
        io.emit('game-state', { players, food });
        updateOnlineCount();
    });
    
    // Handle movement
    socket.on('move', (direction) => {
        if (players[socket.id]) {
            const player = players[socket.id];
            
            switch(direction) {
                case 'up':
                    if (player.direction.y !== 1) {
                        player.direction = {x: 0, y: -1};
                    }
                    break;
                case 'down':
                    if (player.direction.y !== -1) {
                        player.direction = {x: 0, y: 1};
                    }
                    break;
                case 'left':
                    if (player.direction.x !== 1) {
                        player.direction = {x: -1, y: 0};
                    }
                    break;
                case 'right':
                    if (player.direction.x !== -1) {
                        player.direction = {x: 1, y: 0};
                    }
                    break;
            }
        }
    });
    
    // Handle chat messages
    socket.on('chat-message', (message) => {
        if (players[socket.id]) {
            io.emit('chat-message', {
                playerName: players[socket.id].name,
                message: message
            });
        }
    });
    
    // Handle find match
    socket.on('find-match', () => {
        if (players[socket.id]) {
            players[socket.id].body = [{x: Math.floor(Math.random() * GRID_SIZE), y: Math.floor(Math.random() * GRID_SIZE)}];
            players[socket.id].direction = {x: 0, y: 1};
            players[socket.id].score = 0;
            
            io.emit('game-state', { players, food });
        }
    });
    
    // Handle disconnect
    socket.on('disconnect', () => {
        if (players[socket.id]) {
            delete players[socket.id];
            io.emit('player-left', socket.id);
            io.emit('game-state', { players, food });
            updateOnlineCount();
        }
    });
});

// Game loop
setInterval(() => {
    // Move players
    Object.values(players).forEach(player => {
        if (player.direction.x !== 0 || player.direction.y !== 0) {
            const head = {x: player.body[0].x + player.direction.x, y: player.body[0].y + player.direction.y};
            
            // Wrap around edges
            if (head.x < 0) head.x = GRID_SIZE - 1;
            if (head.x >= GRID_SIZE) head.x = 0;
            if (head.y < 0) head.y = GRID_SIZE - 1;
            if (head.y >= GRID_SIZE) head.y = 0;
            
            player.body.unshift(head);
            
            // Check for food collision
            let ateFood = false;
            for (let i = 0; i < food.length; i++) {
                if (head.x === food[i].x && head.y === food[i].y) {
                    player.score += 1;
                    ateFood = true;
                    
                    // Remove food and generate new one
                    food.splice(i, 1);
                    food.push({
                        x: Math.floor(Math.random() * GRID_SIZE),
                        y: Math.floor(Math.random() * GRID_SIZE)
                    });
                    
                    break;
                }
            }
            
            if (!ateFood) {
                player.body.pop();
            }
            
            // Check for collisions with other players
            Object.values(players).forEach(otherPlayer => {
                if (player.id !== otherPlayer.id) {
                    for (let i = 0; i < otherPlayer.body.length; i++) {
                        if (head.x === otherPlayer.body[i].x && head.y === otherPlayer.body[i].y) {
                            // Player died
                            player.body = [{x: -1, y: -1}];
                            player.direction = {x: 0, y: 0};
                            break;
                        }
                    }
                }
            });
        }
    });
    
    // Send updated game state to all players
    io.emit('game-state', { players, food });
}, 100); // Update every 100ms

function updateOnlineCount() {
    io.emit('online-count', Object.keys(players).length);
}

// Start server
const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
});
